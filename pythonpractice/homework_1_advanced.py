# -*- coding: utf-8 -*-
"""CT Chen - Python_homework_1_advanced.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QhISNAHuCrJOa4JNoslhXYz9NxAdyf0T

In this homework I will include some problems outside of the material we have learned. These problems are things I feel you should already know how to complete since you are in the advanced class. The students in the beginner course will have to do these problems before they reach the advanced class start point. If you are struggling to complete this homework, you may want to consider tuning into the beginner course around lecture 4, onward.

#1)

Using the **numpy array** stored in the variable "z" shown below, use the print function to show the following elements of "z" by writing the correct indicies. Each sample below should be be aquired using a single index extraction (one set of brackets) call on "z".

* [90, 100, 110, 120]
* 2
* 120
* 502
* [2, 3]
* [501, 502, 503]
* [100, 501]
* [4, 503]


Note: You should be using the print function exactly eight times.
"""

import numpy as np

z = np.array([[1, 2, 3, 4], [90, 100, 110, 120], [500, 501, 502, 503]])
# YOUR CODE GOES BELOW
print(z[1])
print(z[0,1])
print(z[1,3])
print(z[2,2])
print(z[0, 1:3])
print(z[2, 1:4])
print(z[1:3, 1])
print(z[0::2, 3])

"""#2)

Use the *enumerate()* function in a for-loop to:

* replace each element, *i*, of array "c" with each element of a, b, and c in the following way

  * a_i  -  b_i  *  c_i

* However, if c_i is greater than or equal to 100, use the following formula to replace the element, *i*, in list "c"
  * a_i  *  b_i

In the instructions above, I am using [mathematical notation](https://www.purplemath.com/modules/series.htm) for elements within a sequence (array) because I want you to figure out how to index these variables on your own. For those of you not familliar with this notation, here is what this means:

If we have an array called "G", I could show the first element of *G* by saying
* g_i, where i = 0

Since we usually shouldnt use uppercase letters in Python varaibles due to the [PEP8](https://www.python.org/dev/peps/pep-0008/) standard, all of the variables here are lowercase.
"""

import numpy as np
a = list(np.random.randint(-10, 10, 20))
b = list(np.random.randint(-50, 50, len(a)))
c = list(np.random.randint(90, 110, len(a)))

print(a, b, c)

# YOUR CODE GOES BELOW
for (i, valc) in enumerate(c):
        if (valc >= 100):
          c[i] = a[i]*b[i]
        else:
          c[i] = a[i]-b[i]*c[i]
print(c)

"""#3)

Use the *zip()* function to complete problem #2 without using the *enumerate()* function.
"""

import numpy as np
a = list(np.random.randint(-10, 10, 20))
b = list(np.random.randint(-50, 50, len(a)))
c = list(np.random.randint(90, 110, len(a)))

print(a, b, c)

# YOUR CODE GOES BELOW

x = list(zip(a, b, c))

for ai, bi, ci in x:
  i = x.index((ai, bi, ci))
    # print(ai)
    # print(bi)
    # print(ci)
  if (ci >= 100):
    c[i] = ai*bi
  else:
    c[i] = ai-bi*ci
print(c)

"""#4)

Write a function (definition) that will convert temperatures between celsius, fahrenheit, and kelvin in the following way:

* The function should have three input parameters:
  * temperature (float)
  * input temperature type (a single letter string like 'c', 'f', or 'k')
  * output temperature type (a single letter string like 'c', 'f', or 'k')
* Set the **default** input temperature type to celsius
* Set the **default** output temperature type to kelvin

* There should be two outputs:
  * The new temperature that was calculated
  * A string which tells us which temperature unit this new temperature is

Try converting three different temperatures to make sure your code works!
* In your first test, use only a temparture argument, letting the other inputs automatically use thier defualts
* In the second test, use keyword arguments for all three inputs to set whatever inputs you want to try.
* In the third test, use keyword arguments for all three inputs to set whatever inputs you want to try, but scamble the arguments into a different order.
  * Remember, this works because "using keyword arguments allows you to skip arguments or place them out of order because the Python interpreter can use the keywords provided to match the values with parameters."
"""

t0 = 54.77

# YOUR CODE GOES BELOW

def tempconvert(temp, inType = 'c', outType = 'k'):

    if (inType=='f'):
      if (outType=='c'):
        return(temp - 32.0) * (5.0/9.0)
      elif (outType=='k'):
        return((temp - 32.0) * (5.0/9.0)) + 273.15
    elif (inType=='c'):
      if (outType=='f'):
        return(temp * (9.0/5.0)) + 32.0
      elif (outType=='k'):
        return temp + 273.15
    elif (inType=='k'):
        if (outType=='c'):
          return temp - 273.15
        elif (outType=='f'):
          return ((temp-273.15) * (9.0/5.0)) + 32.0
    else:
        print("Inputs need to be 'c', 'f', or 'k' for temperature scales")

print(tempconvert(t0))
print(tempconvert(328, 'k', 'c'))
print(tempconvert(inType='k', temp=328, outType='c'))
print(tempconvert(0))
print(tempconvert(0, 'k', 'c'))

"""#5)

* Choose an image you find on the internet and copy the image URL (on Google Chrome, right click on image and select "copy image address", similar for other browsers). If you cant find an image like this, use the URL already given.
* Paste the image's URL to replace the one given below
* Convert the image to a numpy array (use the same variable, "img")
* Plot the image
"""

from PIL import Image
import numpy as np
import requests
from io import BytesIO
import matplotlib.pyplot as plt

url = 'https://i.redd.it/jmohn0zm7x351.png'
response = requests.get(url, stream=True)
img = Image.open(response.raw)

# # YOUR CODE GOES BELOW
img = np.asarray(img)

#plotting image
plt.figure()
plt.imshow(img[:, :, :])

"""#6)

Using the image you downloaded in problem #5, 
* show images of the red, green and blue *channels* separately in different figures.
* In a fourth plot, lets see an image of all three channels added together and divided by 765.

Note: Most images you find will be a 3D array. The third axis usually has a length of three, representing the R, G, and B channels.
"""

imgr = np.copy(img)  
# red image
imgr[:,:,1] =0
imgr[:,:,2] =0
plt.figure()
plt.imshow(imgr[:, :, :])

imgg = np.copy(img)  
# green image
imgg[:,:,0] =0
imgg[:,:,2] =0
plt.figure()
plt.imshow(imgg[:, :, :])

imgb = np.copy(img) 
# Blue image
imgb[:,:,0] =0
imgb[:,:,1] =0
plt.figure()
plt.imshow(imgb[:, :, :])

imgr_float = imgr.astype(float)
imgr_float[:, :, 0] *= (1.0/765)
imgg_float = imgg.astype(float)
imgg_float[:, :, 1] *= (1.0/765)
imgb_float = imgb.astype(float)
imgb_float[:, :, 2] *= (1.0/765)
plt.figure()
plt.title('All 3 layers added up but they\'re divided by 765')
plt.imshow(imgr_float[:, :, :])
plt.imshow(imgg_float[:, :, :])
plt.imshow(imgb_float[:, :, :])

"""# 7)

The data here is from an electrocardiogram. Its units are millivolt (mV) sampled at 360 Hz.
Make a plot of the electrocardiogram data.
* Variable **ecg** should be plotted with just a black line.
* Any values in variable **ecg** below zero should be plotted with red markers and no line.
* **Make sure both of these plotted data (red and black) are aligned on the x-axis (time)**


Your plot should have:
* title
* axes labels
* legend

Try to make all labels as scientific and conscise as you can
"""

from scipy.misc import electrocardiogram

ecg = electrocardiogram()

### YOUR CODE GOES BELOW ###
posecg = ecg.copy()
negecg = ecg.copy()

posecg[posecg <= 0] = np.nan
negecg[negecg > 0] = np.nan

plt.figure(figsize=(15, 15))

plt.title('Electrocardiogram Data')
plt.xlabel('Time')
plt.ylabel('mV (sampled at 360 Hz)')

plt.plot(posecg, '-k', label='ECG data')
plt.plot(negecg, '.r', label='ECG data below 0')

plt.legend()

"""# 8)

You have completed an experiment where you measured the distance a comet moved over a short period of time. 

The data from the observations has been saved into the variables "time_yr" and "dist_km". 

The variables "time_yr" and "dist_km" are the time in years and the distance in kilometers, respectively.

Use cubic interpolation to determine the distance the comet traversed at the times [2.5, 10.66, 34.91] years.


Plot your original data and the new data.
"""

import numpy as np

time_yr = np.linspace(0, 50, 10)  # Time in years

dist_km = 2.0 + 1000 * np.exp(time_yr / 20) +  500 * np.sin(time_yr / 2.0)  # Distance in kilometers


##################################################################

### YOUR CODE GOES BELOW ###

# Does a cubic fit
pfc = np.polyfit(time_yr, dist_km, deg=3)

# Evaluate the fit at the 3 given points (plus also graphing the cubic fit)
dist = np.polyval(pfc, time_yr)
dist_1 = np.polyval(pfc, 2.5)
dist_2 = np.polyval(pfc, 10.66)
dist_3 = np.polyval(pfc, 34.91)

# Plot all of this data
plt.figure(figsize=(10, 10))
plt.plot(time_yr, dist_km, '-k', label='Distance function')
plt.plot(time_yr, dist, '-c', label='Cubic fit of distance')
plt.plot(2.5, dist_1, '.r', label='dist at t=2.5')
plt.plot(10.66, dist_2, '.g', label='dist at t=10.66')
plt.plot(34.91, dist_3, '.b', label='dist at t=34.91')

plt.xlabel('Time (year)')
plt.ylabel('Distance (km)')

plt.legend()

print('distance at t=2.5 is ' + str(dist_1))
print('distance at t=10.66 is ' + str(dist_2))
print('distance at t=34.91 is ' + str(dist_3))

"""# 9)

* Perform a linear fit (degree 1 polynomial) on the following (x, y) data
* Make a single plot containing the following data:
  * Plot the (x, y) data as points (no line)
  * Plot the linear fit as a line (no markers)
  * Add a legend to the plot to identify the original data and the fit
"""

from sklearn import linear_model, datasets  # Import sample dataset creation function
import numpy as np

# Create psuedo random dataset
x, y, __ = datasets.make_regression(n_samples=1000, n_features=1,
                                      n_informative=10, noise=25,
                                      coef=True, random_state=54)

x = np.ravel(x) # Make array into a vector
y = np.ravel(y) # Make array into a vector

si = np.argsort(x) # Sort x values. return the sorted index

x = x[si] # Apply the sort
y = y[si] # Apply the sort


##############################################################################

### YOUR CODE GOES BELOW ###

# Perform the 1-degree polynomial fit
pfc = np.polyfit(x, y, deg=1)

# Evaluate the fit at some points
yfit = np.polyval(pfc, x)

# Plot all of this data
plt.figure(figsize=(10,10))
plt.plot(x, y, '.k', label='Original Data')
plt.plot(x, yfit, '-m', label='Linear Fit')
plt.legend()

"""# 10)

* Extract rows 10 to 100 of column 5 from the following image ("img") 
* make a line plot of the extracted data
* Perform a smoothing spline fit (using the csaps package) to the extracted data using a smoothing param of 0.9
* Evaluate the fit at 1000 linearly spaced points across the extracted data
* Plot the new fit data in the same figure as the extracted data
"""

!pip install csaps

import csaps

import numpy as np
from PIL import Image
import numpy as np
import requests
from io import BytesIO
import matplotlib.pyplot as plt

url = "https://images-na.ssl-images-amazon.com/images/I/61MZ-5YHutL._SX425_.jpg"
response = requests.get(url, stream=True)
img = Image.open(response.raw)
img = np.array(img)

plt.figure()
plt.imshow(img)
plt.figure()
# print(img.shape)
################################################################################

### YOUR CODE GOES BELOW ###

imgselected = img[10:100, 5, :]
toplot = imgselected[:, 0]

x = np.arange(90)
sp = csaps.UnivariateCubicSmoothingSpline(x, toplot, smooth=0.9)
xs = np.linspace(x[0], x[-1], 1000)
ys = sp(xs)

plt.figure(figsize=(10,6))
plt.plot(toplot, '-r', label='Data from the image')
plt.plot(xs, ys, '-g', label='Smoothing spline fit')
plt.legend()